# Progress Log

## 2026-02-08 12:11:26 +03 - Build Environment Audit
- Completed: Audited local tools against `AGENTS.md` build environment.
- Found: `Darwin` host, `nasm 3.01`, `qemu-system-i386 10.2.0`, `GNU Make 3.81`.

## 2026-02-08 12:15:25 +03 - i686 Toolchain Installation
- Completed: Installed and verifiedrequired packages with Homebrew: `i686-elf-binutils`, `i686-elf-gcc`.
- Result: `AGENTS.md` build-environment toolchain requirement is satisfied.

## 2026-02-08 - Phase 1, Task 1: MBR Bootloader
- Completed: MBR boot sector (`boot/mbr.asm`) that prints "ClaudeOS booting..." via BIOS INT 0x10.
- Created `Makefile` with `all`, `run`, and `clean` targets.
- Writer/reviewer workflow caught missing `cld` (direction flag bug), missing `cli` before segment init, and unsaved boot drive (DL).
- Verified: 512 bytes, 0xAA55 signature, boots and prints in QEMU.

## 2026-02-08 - Phase 1, Task 2: A20, GDT, Protected Mode
- Completed: Extended `boot/mbr.asm` with A20 enable (KBC + fast A20 fallback), flat GDT (null/code/data), and protected mode switch.
- Reviewer caught fast A20 logic bug (skipped verification when port bit was already set) and missing `cld` in 32-bit context. Both fixed.
- 32-bit confirmation writes to VGA text buffer at 0xB8000.
- Verified: 512 bytes, boots through PM switch in QEMU, no triple fault.

## 2026-02-08 - Phase 1, Task 3: Stage 2 Loader + C Kernel Entry
- Completed: Split MBR into 3-stage boot chain: MBR → stage2 → C kernel.
- MBR (`boot/mbr.asm`): loads 16 sectors from LBA 1 to 0x7E00 via INT 13h, jumps to stage2.
- Stage 2 (`boot/stage2.asm`): A20/GDT/PM switch, jumps to kernel at 0x8000.
- Kernel entry (`kernel/kernel_entry.asm`): BSS zero, calls `kernel_main()`.
- Kernel (`kernel/kernel.c`): minimal — halts for now (Task 4 adds VGA).
- Linker script (`linker.ld`): flat binary at 0x8000.
- Makefile: builds MBR + stage2 + kernel, concatenates into `os.bin`, pads to 32KB.
- Reviewer caught: need libgcc linking (switched to gcc as linker driver), boot drive passthrough to stage2, and disk image padding issue (fixed: 32KB image for 16-sector read).

## 2026-02-08 - Phase 1, Tasks 4+5: VGA Text Mode + Serial Port Output
- Completed: VGA text-mode driver and COM1 serial debug channel, implemented in parallel by two writer agents and merged.
- New files: `kernel/io.h` (shared port I/O), `kernel/vga.h`/`vga.c` (VGA driver), `kernel/serial.h`/`serial.c` (serial driver).
- VGA: 80x25 text mode, hardware cursor, scrolling, color support, clear screen on init.
- Serial: COM1 at 38400 baud, 8N1, FIFO enabled, THRE busy-wait, `\n` → `\r\n` translation.
- Reviewer found 1 bug: `vga_buffer` needed `volatile` for MMIO correctness at `-O2`. Fixed.
- Updated `kernel/kernel.c`: prints "ClaudeOS v0.1" in white via VGA, sends debug messages via serial.
- Updated Makefile: compiles `vga.o`/`serial.o`, links into kernel, added `-serial stdio` to QEMU.
- Verified: VGA memory shows "ClaudeOS" (0x0F attr = white), serial log shows both init messages.

## 2026-02-08 - Phase 2, Tasks 6+7: IDT/ISR + PIC/IRQ
- Completed: IDT setup with 256 entries, 32 ISR exception stubs, PIC remapping, 16 IRQ stubs.
- Task 6 files: `kernel/idt.h`/`idt.c` (IDT management), `kernel/isr.h`/`isr.c` (exception handler with register dump), `kernel/isr_stubs.asm` (32 stubs, error-code aware).
- Task 7 files: `kernel/pic.h`/`pic.c` (8259 PIC remap: master 0x20, slave 0x28, all masked), `kernel/irq.h`/`irq.c` (dispatch table + IDT gates 32-47), `kernel/irq_stubs.asm` (16 stubs).
- Orchestrator caught merge bug: IRQ stubs had reversed push order (segments-then-pushad vs pushad-then-segments in ISR stubs). Fixed to match `struct isr_regs`.
- Reviewer found 0 bugs, 1 RISK (spurious IRQ handling deferred), 1 STYLE (KERNEL_CS shared constant — fixed).
- `kernel_main()` now calls `idt_init()`, `irq_init()`, then `sti`.
- Verified: boots in QEMU, serial shows all 4 init stages, no triple fault.

## 2026-02-08 - Phase 2, Task 8: PIT Timer Interrupt
- Completed: PIT channel 0 programmed in mode 2 (rate generator) at 100 Hz.
- New files: `kernel/pit.h`/`pit.c` (PIT driver with IRQ0 handler, global tick counter).
- Modified: `kernel/pic.c` — added `pic_clear_mask()` for unmasking individual IRQ lines.
- Reviewer found: divisor comment was 11932 but C integer division gives 11931 — fixed comments/log.
- Reviewer caught: `pic_clear_mask` for slave IRQs should also unmask IRQ2 (cascade) on master — fixed.
- Added bounds check to `pic_clear_mask` (matching `irq_register_handler` pattern).
- Verified: ~190 IRQ0 interrupts in 2 seconds (~95 Hz effective, consistent with 100 Hz target).

## 2026-02-08 - Phase 2, Task 9: Physical Memory Manager
- Completed: E820 BIOS memory detection in stage2 + bitmap-based physical page frame allocator.
- Modified `boot/stage2.asm`: expanded to 1024 bytes (2 sectors), added E820 detection via INT 0x15/EAX=0xE820, stores map at 0x0500.
- Kernel origin moved from 0x8000 to 0x8200 (linker.ld, kernel_entry.asm updated).
- New files: `kernel/pmm.h`/`pmm.c` — bitmap allocator (1 bit per 4KB frame, 32KB bitmap for 1GB max).
- PMM marks all frames used, then frees only E820 Type 1 regions above 1MB.
- Reviewer caught: `pmm_free_frame(0)` could corrupt IVT — added guard rejecting frees below 1MB.
- Orchestrator caught: GCC 15 `-Warray-bounds` false positive on low-address pointers — fixed with targeted `#pragma GCC diagnostic`.
- Verified in QEMU (-m 128): 6 E820 entries detected, 32480 frames (129920 KB) marked free.

## 2026-02-08 - Phase 2, Task 10: Paging Enabled, Higher-Half Kernel
- Completed: Enabled x86 paging and remapped kernel to higher half (virtual 0xC0000000+).
- Boot chain updated: MBR loads 62 sectors; stage2 copies kernel from 0x8200 to physical 0x100000; kernel_entry sets up boot page tables, enables paging, jumps to higher-half.
- Paging design: single boot page table maps first 4MB; PD[0]=identity (removed after jump), PD[768]=higher-half (0xC0000000), PD[1023]=recursive mapping.
- Kernel GDT defined in kernel_entry.asm .data section, reloaded via LGDT after entering higher half (stage2 GDT at 0x7Exx inaccessible after identity map removal).
- Boot page tables placed in `.boot_pgdir` section (after .bss in linker script) to avoid destruction during BSS zeroing while paging is active.
- Modified files: `boot/mbr.asm` (62 sectors), `boot/stage2.asm` (kernel copy to 0x100000), `linker.ld` (virtual 0xC0100000, .boot_pgdir section), `kernel/kernel_entry.asm` (full rewrite: paging setup, GDT reload, identity unmap), `kernel/vga.h` (VGA at 0xC00B8000), `kernel/pmm.h`/`pmm.c` (E820 at 0xC0000500, kernel page reservation), `kernel/kernel.c` (paging status message), `Makefile` (comment update).
- PMM now reserves kernel physical pages (0x100000 to _kernel_end, 17 frames) to prevent allocating over the running kernel. Removed GCC #pragma workaround (no longer needed at high virtual address).
- Verified in QEMU (-m 128): CR0.PG=1, EIP=0xC01xxxxx, GDT at 0xC01xxxxx, PIT timer interrupts firing at higher-half addresses. Serial shows full boot with 32463 free frames (129852 KB). No triple faults.

## 2026-02-09 00:39:21 +0300 - Phase 2, Task 11: Kernel Heap (`kmalloc`/`kfree`)
- Completed: Added a kernel heap allocator with `kheap_init()`, `kmalloc(size)`, and `kfree(ptr)` in `kernel/heap.c` + `kernel/heap.h`.
- Heap design: first-fit free-list allocator with in-heap block headers, block splitting on allocation, and forward/backward coalescing on free.
- Virtual heap range implemented per project layout: `0xC1000000 - 0xC1FFFFFF` (16MB).
- Added runtime paging helpers in `kernel/paging.c` + `kernel/paging.h` using existing recursive mapping (`0xFFFFF000` PD, `0xFFC00000` PT window):
  - `paging_map_page()`
  - `paging_unmap_page()`
  - `paging_get_phys_addr()`
- Heap grows on demand: when no suitable free block exists, allocator requests physical frames from PMM and maps them into heap virtual space page-by-page.
- Modified `kernel/kernel.c`: initialize kernel heap after PMM init and run a small `kmalloc`/`kfree` self-test.
- Modified `Makefile`: added paging/heap sources and objects to kernel build.
- Reference docs consulted from `docs/core/` while implementing:
  - `Memory_Allocation.md` (allocator layering + kernel heap abstraction)
  - `Paging.md` (recursive mapping manipulation pattern + TLB notes)
  - `TLB.md` (TLB invalidation requirements)
  - `Fractal_Page_Mapping.md` (self-referencing directory concept)
  - `Writing_a_memory_manager.md` (first-fit + split/coalesce structure)
- Verified in QEMU (`-display none -serial stdio`): boot succeeds, PMM initializes, heap initializes, and serial reports `KHEAP: self-test passed`.
- Current scope note: `kfree` returns blocks to the heap free-list (reusable by future `kmalloc`) but does not yet shrink the heap by unmapping/releasing frames back to PMM.

## 2026-02-09 00:57:27 +0300 - Phase 3, Task 12: PS/2 Keyboard Driver (IRQ1, scancode -> ASCII)
- Completed: Added PS/2 keyboard driver in `kernel/keyboard.c` + `kernel/keyboard.h`.
- Driver features:
  - IRQ1 handler registration via `irq_register_handler(1, ...)`.
  - PIC unmasking for IRQ1 via `pic_clear_mask(1)`.
  - Basic PS/2 controller setup using ports `0x60/0x64` (disable ports, flush output, update config byte, re-enable first port).
  - Keyboard scanning enable command (`0xF4`) with ACK check (`0xFA`).
  - Scan code set 1 (US QWERTY) to ASCII translation with `Shift` and `CapsLock` handling.
  - Non-blocking ASCII ring buffer API: `keyboard_read_char()`.
- Integration:
  - Updated `kernel/kernel.c` to initialize keyboard before `sti`.
  - Main loop now drains translated keypresses to serial output for debug visibility.
  - Updated `Makefile` to build/link `kernel/keyboard.c`.
- Reference docs consulted from `docs/core/`:
  - `PS_2_Keyboard.md` (scan code set 1 table, make/break behavior, E0 prefix behavior)
  - `I8042_PS_2_Controller.md` (status bits, command/data port usage, controller config byte behavior)
- Verified:
  - `make` builds cleanly with `-Wall -Wextra -Werror`.
  - Boot tested in QEMU (`-display none -serial stdio`): kernel reaches steady state and logs `[KBD] PS/2 keyboard initialized (IRQ1, set1->ASCII)`.
  - Interactive keypress test in QEMU window on `2026-02-09 01:01:17 +0300` passed; serial echoed typed input (`aAaaaaAAAhello codex this is cool!!`).

## 2026-02-09 01:07:16 +0300 - Phase 3, Task 13: VGA Text Driver (scrolling + cursor polish)
- Completed: Upgraded VGA text driver behavior in `kernel/vga.c` + `kernel/vga.h` for milestone Task 13.
- Added public VGA cursor/screen helpers:
  - `vga_clear()`
  - `vga_set_cursor(row, col)`
  - `vga_get_cursor(&row, &col)`
- Improved text semantics in `vga_putchar()`:
  - Added backspace (`'\b'`) handling that moves cursor backward and erases the previous character.
  - Retained newline/carriage-return/tab handling and existing bottom-of-screen scrolling behavior.
- Internal cleanup: added cursor clamping helper to guarantee hardware cursor writes stay in bounds.
- Reference docs consulted from `docs/core/`:
  - `Text_Mode_Cursor.md` (hardware cursor control registers and update model)
  - `Printing_To_Screen.md` (text mode memory/cursor basics and scrolling expectations)
- Verified:
  - `make` builds cleanly with `-Wall -Wextra -Werror`.
  - Boot smoke test passed in QEMU (`-display none -serial stdio`) using a copied image (`/tmp/os_task13_test.bin`) because the primary image was locked by another running QEMU session.

## 2026-02-09 01:10:23 +0300 - Phase 3, Task 14: Basic Kernel Console (type and see output)
- Completed: Added a basic interactive kernel console in `kernel/console.c` + `kernel/console.h`.
- Console behavior:
  - Prints an initial prompt (`claudeos> `) on VGA.
  - Echoes typed printable characters to VGA.
  - Handles Enter (submits line, moves to new line, prints next prompt).
  - Handles Backspace with in-line deletion support.
  - Maintains a fixed-size current line buffer (128 bytes).
- Integration:
  - Updated `kernel/kernel.c` to initialize console after keyboard setup.
  - Main loop now routes keyboard input through `console_handle_char()` instead of direct serial echo.
  - Updated `Makefile` to compile and link `kernel/console.c`.
- Reference docs consulted from `docs/core/`:
  - `Terminals.md` (ASCII control semantics for Enter/Backspace and terminal input expectations)
  - `Printing_To_Screen.md` (text-mode output behavior and cursor progression)
  - `Text_Mode_Cursor.md` (hardware cursor update model in text mode)
- Verified:
  - `make` builds cleanly with `-Wall -Wextra -Werror`.
  - Boot smoke test passed in QEMU (`-display none -serial stdio`) with copied image (`/tmp/os_task14_test.bin`), serial log includes `[CONSOLE] Initialized`.
  - Interactive VGA typing validated in QEMU window on `2026-02-09 01:14:23 +0300`: prompt rendering, line echo, and serial mirror logs all worked (`[CONSOLE] hey codex`, `[CONSOLE] this is cool!`).

## 2026-02-09 01:18:01 +0300 - Phase 4, Task 15: Process Control Blocks + Kernel-Mode Processes
- Completed: Added process subsystem in `kernel/process.c` + `kernel/process.h`.
- PCB implementation:
  - Fixed-size PCB table (`PROCESS_MAX_COUNT = 16`).
  - Process metadata fields for upcoming scheduler/context-switch work: PID, state, ESP/EBP/EIP, CR3, kernel stack metadata, entry function, and name.
  - Bootstrap process registration (`kernel_main`) at init time.
- Kernel process support:
  - `process_create_kernel(name, entry, arg)` creates READY kernel-mode processes with allocated kernel stacks.
  - `process_run_kernel(pid)` executes READY kernel process entries and transitions them to TERMINATED when they return.
  - `process_dump_table()` prints active PCB state to serial for debugging.
- Integration:
  - Updated `kernel/kernel.c` to initialize process subsystem.
  - Added two demo kernel processes (`demo_a`, `demo_b`) to validate process creation/execution/state transitions.
  - Updated `Makefile` to compile/link `kernel/process.c`.
- Reference docs consulted from `docs/core/`:
  - `Processes_and_Threads.md` (process/thread model and scheduling context)
  - `Kernel_Multitasking.md` (TCB/stack state expectations)
  - `Context_Switching.md` (state components needed for software switches)
  - `Cooperative_Multitasking.md` (cooperative bootstrap style before preemption)
- Verified:
  - `make` builds cleanly with `-Wall -Wextra -Werror`.
  - Boot smoke test passed in QEMU (`-display none -serial stdio`) with copied image (`/tmp/os_task15_test.bin`).
  - Serial confirms PCB lifecycle: process creation (`pid=2`, `pid=3`), execution, termination, and PCB dump output.
- Scope note:
  - `process_run_kernel()` is a Task 15 cooperative bootstrap helper that directly invokes process entry functions.
  - Full register/stack context switching is intentionally deferred to Task 16.

## 2026-02-09 01:29:24 +0300 - Stability Hardening Pass (pre-Task 16)
- Completed: Fixed six high-priority future-bug risks identified in a kernel audit.
- Process subsystem hardening (`kernel/process.c`, `kernel/process_stubs.asm`, `Makefile`):
  - Added `process_call_on_stack()` assembly helper so kernel process entries now execute on their own kernel stack (not `kernel_main`'s stack).
  - Added process slot release path: finished processes now free their kernel stack and clear PCB slot back to `UNUSED`, preventing slot exhaustion and heap leaks.
- Paging hardening (`kernel/paging.c`):
  - Added PDE permission propagation/upgrade for user mappings (`PAGE_USER`) so future ring-3 page mappings can succeed correctly.
- PMM safety hardening (`kernel/pmm.c`):
  - Added allocation-ownership bitmap; `pmm_free_frame()` now frees only frames actually returned by `pmm_alloc_frame()`, preventing accidental frees of reserved/foreign frames.
- Keyboard race hardening (`kernel/keyboard.c`):
  - Made ring-buffer pop (`keyboard_read_char`) IRQ-safe using interrupt flag save/restore around head/tail updates.
- Reference docs consulted from `docs/core/`:
  - `Kernel_Multitasking.md` (per-task kernel stack model)
  - `Context_Switching.md` (state/privilege assumptions for future scheduler work)
  - `Processes_and_Threads.md` (PCB/process lifecycle expectations)
- Verified:
  - `make` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU boot smoke test passed (`/tmp/os_audit_fix_test.bin`), including process creation/execution and post-run PCB dump.
- Deferred risk note:
  - Spurious IRQ7/IRQ15 handling remains deferred by request and should be addressed before broader hardware bring-up.

## 2026-02-09 01:34:30 +0300 - Phase 4, Task 16: Context Switching
- Completed: Implemented cooperative kernel context switching infrastructure for i686.
- New low-level switch primitive:
  - Added `process_switch(old_esp*, new_esp)` in `kernel/process_stubs.asm` (pure assembly).
  - Switch saves/restores callee-saved context and returns into the next process stack frame.
- Process subsystem refactor (`kernel/process.c`, `kernel/process.h`):
  - Added scheduler-facing APIs:
    - `process_yield()`
    - `process_run_ready()`
  - Added per-process bootstrap entry (`process_bootstrap`) so new processes start on their own kernel stacks.
  - `process_create_kernel()` now builds an initial stack frame compatible with `process_switch`.
  - Added deferred zombie reaping to free terminated process stacks only after switching away safely.
- Kernel integration (`kernel/kernel.c`):
  - Demo kernel processes now call `process_yield()` to exercise cooperative switching.
  - `kernel_main` runs the ready queue via `process_run_ready()` before entering console loop.
- Build integration (`Makefile`):
  - Added `kernel/process_stubs.asm` to kernel object list.
- Reference docs consulted from `docs/core/`:
  - `Context_Switching.md` (software switch model, stack/EIP semantics)
  - `Kernel_Multitasking.md` (per-task kernel stack context handling)
  - `Cooperative_Multitasking.md` (cooperative scheduling bootstrap pattern)
- Verified:
  - `make` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU smoke test (`/tmp/os_task16_test.bin`) shows expected interleaving and completion:
    - `demo process A tick` / `demo process B tick` alternating via yields
    - both processes exit
    - PCB dump returns to only `kernel_main` RUNNING
  - Console still initializes after process demo run.
  - Interactive `make run` validation on `2026-02-09 01:39:21 +0300` passed:
    - process interleaving/exits and PCB dump matched expected output
    - console handled sustained key-hold input without freeze
    - line submit and serial mirror logs remained correct.

## 2026-02-09 01:44:19 +0300 - Phase 4, Task 17: TSS Setup
- Completed: Added protected-mode Task State Segment initialization and task register load for i686.
- New files: `kernel/tss.c`, `kernel/tss.h`.
- GDT integration: `kernel/kernel_entry.asm` now reserves a runtime-populated TSS descriptor at selector `0x18`.
- TSS configuration: `ss0=0x10`, `esp0` points to a dedicated aligned kernel stack, and `iomap_base=sizeof(TSS)`.
- Descriptor configuration: base/limit set at runtime, access byte `0x89`, byte-granularity flags (`0x0`).
- Kernel integration: `kernel/kernel.c` now calls `tss_init()` before enabling interrupts and logs `TSS initialized`.
- Build integration: `Makefile` now compiles and links `kernel/tss.c`.
- Reference docs consulted from `docs/core/`:
  - `Task_State_Segment.md`
  - `GDT_Tutorial.md`
  - `Getting_to_Ring_3.md`
  - `Context_Switching.md`
- Verified:
  - `make` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU smoke run (`qemu-system-i386 -display none -serial stdio`) reaches console loop and prints `TSS initialized`.
- Future note: `esp0` is currently a bootstrap kernel stack; for ring-3 syscall/interrupt return paths, update `esp0` on task switches in later milestones.

## 2026-02-09 01:54:40 +0300 - Interrupt/TSS Hardening Fixes
- Completed: Fixed two audit findings requested after Task 17.
- TSS ordering hardening:
  - Updated `kernel/tss.c` so `ltr` inline assembly includes a `memory` clobber, preventing compiler reordering across TSS/GDT setup writes.
- Spurious IRQ handling:
  - Added PIC ISR read helpers in `kernel/pic.c` + declarations in `kernel/pic.h`.
  - Added `pic_is_spurious_irq()` handling for IRQ7/IRQ15 using ISR checks from OSDev guidance.
  - Corrected spurious IRQ15 behavior: send EOI to master PIC only, skip slave EOI and IRQ dispatch.
  - Updated `kernel/irq.c` to detect and early-return on spurious IRQ7/15 before normal dispatch/EOI flow.
- Reference docs consulted from `docs/core/`:
  - `8259_PIC.md` (ISR/IRR and spurious IRQ handling)
  - `Task_State_Segment.md` (TSS load sequencing context)
- Verified:
  - `make` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU serial smoke boot reaches stable console loop after init and process demo run.

## 2026-02-09 02:08:24 +0300 - Phase 4, Task 18: Preemptive Round-Robin Scheduler (PIT-driven)
- Completed: Added PIT-driven preemptive scheduling on top of existing software context switching.
- IRQ integration (`kernel/irq.c`):
  - Added timer quantum accounting (`SCHED_QUANTUM_TICKS = 1`).
  - Scheduler preemption now triggers from IRQ0 after handler dispatch and after PIC EOI is sent.
  - This ordering avoids starving future timer IRQs while a context switch is in progress.
- Process subsystem updates (`kernel/process.c`, `kernel/process.h`):
  - Added preemption controls:
    - `process_set_preemption()`
    - `process_is_preemption_enabled()`
    - `process_preempt_from_irq()`
  - Added bootstrap `sti` when preemption is enabled so a fresh process first entered from IRQ context can continue receiving interrupts.
- Kernel integration (`kernel/kernel.c`):
  - Demo processes no longer call `process_yield()`, so scheduling is driven by PIT preemption rather than cooperative yields.
  - Enabled preemption in `kernel_main` via `process_set_preemption(1)` before `sti`.
  - Kept one-time PCB summary print after demo processes exit (`process_count() == 1`).
- Reference docs consulted from `docs/core/`:
  - `Kernel_Multitasking.md`
  - `Context_Switching.md`
  - `8259_PIC.md` (EOI/spurious behavior and PIC ISR semantics)
- Verified:
  - Clean build: `make` with `-Wall -Wextra -Werror`.
  - QEMU serial smoke run shows PIT-driven interleaving without cooperative yields:
    - `demo process A tick` / `demo process B tick` alternate/interleave
    - both demo processes exit
    - PCB table returns to `kernel_main` only.

## 2026-02-09 02:20:53 +0300 - Phase 4, Task 19: Spinlocks and Basic Synchronization
- Completed: Added reusable spinlock and synchronization primitives for preemptive kernel paths.
- New primitives:
  - `kernel/spinlock.h`, `kernel/spinlock.c`
    - `spinlock_lock`, `spinlock_try_lock`, `spinlock_unlock`
    - IRQ-safe helpers: `spinlock_irq_save/restore`, `spinlock_lock_irqsave`, `spinlock_unlock_irqrestore`
  - `kernel/sync.h`, `kernel/sync.c`
    - Counting semaphore: `semaphore_init`, `semaphore_wait`, `semaphore_signal`, `semaphore_value`
    - Mutex wrapper: `mutex_init`, `mutex_lock`, `mutex_unlock`
- Runtime integration:
  - `kernel/heap.c`: added global heap spinlock; `kmalloc`/`kfree` now execute under IRQ-safe lock to prevent allocator metadata corruption under preemption.
  - `kernel/keyboard.c`: replaced manual IRQ flag save/restore around ring-buffer operations with shared spinlock helpers.
- Build integration:
  - `Makefile` updated to compile and link `spinlock.c` and `sync.c`.
- Reference docs consulted from `docs/core/`:
  - `Spinlock.md`
  - `Semaphore.md`
  - `Kernel_Multitasking.md`
  - `Context_Switching.md`
- Verified:
  - `make` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU serial smoke boot passes through scheduler/console loop with expected preemptive demo behavior and no regressions.

## 2026-02-09 02:34:16 +0300 - Codebase Audit (Reviewer Pass 1)
- Completed: Performed a full audit of bootloader, memory management, interrupts, scheduler/process code, and device/console paths.
- Validation:
  - `make clean && make -j4` passes with `-Wall -Wextra -Werror`.
  - Headless QEMU serial smoke boot reaches stable console and process demo completion.
- Reference docs consulted from `docs/core/`:
  - `Disk_access_using_the_BIOS_(INT_13h).md`
  - `Detecting_Memory_(x86).md`
  - `Context_Switching.md`
  - `Task_State_Segment.md`
  - `8259_PIC.md`
- Findings captured for follow-up:
  - Hard-coded stage2/kernel load size limits can silently truncate future kernels.
  - Scheduler state transitions are not IRQ-safe in all call paths (reentrancy risk).
  - TSS `esp0` update path exists but is not wired into task switch flow.
  - PMM E820 free-frame accounting can drift if firmware reports overlapping ranges.
  - Bootloader CHS bulk-read path is brittle across BIOS implementations.

## 2026-02-09 02:46:25 +0300 - Audit Hotfixes: Findings #1 and #2
- Completed: Fixed the two high-priority audit findings requested for immediate remediation.
- Fix #1 (kernel load hard-cap / silent truncation risk):
  - `boot/mbr.asm`: replaced single CHS bulk read with INT 13h extensions (AH=41h capability check + AH=42h DAP reads), split into two chunks to avoid 64KB transfer-boundary issues.
  - `boot/stage2.asm`: replaced fixed 30KB copy constant with `KERNEL_MAX_SECTORS`-driven `KERNEL_COPY_DWORDS`.
  - `Makefile`: introduced `KERNEL_MAX_SECTORS`/`KERNEL_MAX_BYTES`, passed define to NASM for both boot stages, and added hard build failures when `kernel.bin` or final `os.bin` exceed supported limits.
  - Removed silent padding fallback (`|| true`) so over-limit images now fail fast with explicit errors.
- Fix #2 (scheduler reentrancy in mixed IRQ/non-IRQ call paths):
  - `kernel/process.c`: wrapped `process_yield()` scheduler critical section with `spinlock_irq_save()`/`spinlock_irq_restore()` to block IRQ-time reentry while scheduler global state and context switch state are being mutated.
- Reference docs consulted from `docs/core/`:
  - `Disk_access_using_the_BIOS_(INT_13h).md`
  - `Context_Switching.md`
  - `Spinlock.md`
- Verified:
  - Clean rebuild passes: `make -j4` with `-Wall -Wextra -Werror`.
  - QEMU serial smoke run reaches stable init + scheduler + console path with expected process completion and PCB dump.
  - Current image sizing: `kernel.bin` = 16016 bytes, `os.bin` = 65536 bytes.

## 2026-02-09 03:01:42 +0300 - Phase 5, Task 20: Ring 0 -> Ring 3 Transition
- Completed: Added a controlled ring3 transition path using the `iret` method while keeping default boot behavior unchanged.
- GDT updates:
  - `kernel/kernel_entry.asm` now includes user-mode flat segments:
    - User code descriptor at selector `0x20` (DPL=3, access `0xFA`)
    - User data descriptor at selector `0x28` (DPL=3, access `0xF2`)
  - Existing TSS descriptor remains at selector `0x18`.
- User-mode transition module:
  - New files `kernel/usermode.h` and `kernel/usermode.c`.
  - Implements a minimal ring3 probe:
    - maps a user code page and user stack page with `PAGE_USER`
    - sets up an `iret` frame with ring3 selectors (`CS=0x23`, `SS=0x2B`)
    - enters ring3 and intentionally executes `cli` to trigger `#GP` as proof of user privilege level.
  - Updates `tss.esp0` from current kernel ESP immediately before transition.
- Console integration:
  - `kernel/console.c` now supports simple commands:
    - `help` (shows command list)
    - `ring3test` (launches ring3 transition probe)
  - Default `make run` flow remains unchanged unless `ring3test` is entered.
- Build integration:
  - `Makefile` now compiles and links `kernel/usermode.c`.
- Reference docs consulted from `docs/core/`:
  - `Getting_to_Ring_3.md`
  - `GDT_Tutorial.md`
  - `Task_State_Segment.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU serial smoke boot (`make run`) still reaches stable scheduler + console path.
  - Image sizing remains within bootloader cap (`kernel.bin` = 16888 bytes, `os.bin` = 65536 bytes).
  - Full `ring3test` interaction requires manual keyboard input in QEMU window (not automatable via serial-only run).

## 2026-02-09 12:33:40 +0300 - Phase 5, Task 21: TSS Stack Switching on Syscall Path
- Completed: Wired per-task `TSS.esp0` updates into the scheduler/context-switch flow.
- Process scheduler integration:
  - `kernel/process.c` now computes a kernel stack top per task (`process_kernel_stack_top`).
  - `process_yield()` now updates `tss_set_kernel_stack(...)`:
    - on task switches: sets `esp0` for the next scheduled task before `process_switch`.
    - on no-op yields: refreshes `esp0` for the currently running task.
  - Added `process_refresh_tss_stack()` to sync `esp0` to the current task on demand.
  - Added prototype in `kernel/process.h`.
- Kernel init integration:
  - `kernel/kernel.c` now calls `process_refresh_tss_stack()` immediately after `tss_init()` to bind initial `esp0` to the bootstrap task stack context.
- Ring3 test hygiene for upcoming ELF loader work:
  - `kernel/usermode.c` ring3 probe virtual addresses moved away from common ELF base assumptions:
    - code: `0x08000000`
    - stack: `0x08001000`
  - Removed persistent `user_test_prepared` latch and static frame ownership state from ring3 probe setup.
  - `usermode_run_ring3_test()` now refreshes TSS via `process_refresh_tss_stack()` instead of directly writing `esp0` from local inline asm.
- Reference docs consulted from `docs/core/`:
  - `Task_State_Segment.md`
  - `Context_Switching.md`
  - `System_Calls.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU serial smoke boot (`make run`) reaches stable scheduler + console path with no regressions.
  - Serial log now confirms initial synchronization: `[PROC] TSS esp0 synchronized for current task`.
  - Image sizing remains within cap (`kernel.bin` = 17080 bytes, `os.bin` = 65536 bytes).

## 2026-02-09 03:11:44 +0300 - Codebase Audit (Reviewer Pass 2, post-Task 20)
- Completed: Re-audited boot, scheduler, TSS/ring3 transition path, memory manager, and console command integration after Task 20.
- Validation:
  - `make clean && make -j4` passes with `-Wall -Wextra -Werror`.
  - Headless QEMU serial smoke boot reaches stable scheduler + console loop.
  - Automated ring3 probe run performed via QEMU monitor `sendkey` scripting; serial log confirms:
    - command dispatch (`[CONSOLE] ring3test`)
    - ring3 entry marker (`[USER] entering ring3 test...`)
    - expected `#GP` with `CS=0x23` and `DS/ES/FS/GS=0x2B`.
- Reference docs consulted from `docs/core/`:
  - `Getting_to_Ring_3.md`
  - `Task_State_Segment.md`
  - `Context_Switching.md`
  - `Detecting_Memory_(x86).md`
- Findings captured for follow-up:
  - `tss.esp0` update is still not integrated with scheduler task-switch flow (critical before real multi-task ring3/syscall work).
  - Ring3 test mappings are global/static debug mappings and can conflict with future user program load addresses if left enabled.
  - PMM free-frame accounting remains vulnerable to overlap-induced drift on pathological/unsorted E820 maps.

## 2026-02-09 12:42:58 +0300 - Phase 5, Task 22: INT 0x80 Syscall Interface
- Completed: Added a user-callable `INT 0x80` syscall entry path with an initial kernel dispatcher skeleton.
- IDT integration:
  - `kernel/idt.h`: added `IDT_GATE_INT32_USER` (`0xEE`, DPL=3).
  - `kernel/idt.c`: installed vector `0x80` gate to `syscall_int80` using DPL=3 interrupt gate so ring3 code can invoke it.
- Syscall subsystem:
  - New files:
    - `kernel/syscall.h`
    - `kernel/syscall.c`
    - `kernel/syscall_stubs.asm`
  - `syscall_stubs.asm` builds an `isr_regs`-compatible frame, switches to kernel data segments, calls `syscall_handler`, then `iret`s back.
  - `syscall.c` provides:
    - `syscall_init()` (startup marker)
    - `syscall_handler()` with first-call trace marker
    - `syscall_dispatch()` skeleton returning `0xFFFFFFFF` (`-ENOSYS`) for unknown syscall numbers.
- Kernel integration:
  - `kernel/kernel.c` now calls `syscall_init()` and logs syscall interface initialization during boot.
- Ring3 probe update:
  - `kernel/usermode.c` test payload now executes:
    - `mov eax, 0x1234`
    - `int 0x80`
    - `mov ebx, eax`
    - `cli` (expected `#GP` in ring3)
  - This validates syscall entry/return path before triggering the deliberate privilege fault.
- Build integration:
  - `Makefile` updated to compile/link `syscall.c` and `syscall_stubs.asm`.
- Reference docs consulted from `docs/core/`:
  - `System_Calls.md`
  - `Getting_to_Ring_3.md`
  - `Task_State_Segment.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU serial smoke boot (`make run`) reaches stable scheduler + console path and logs:
    - `[SYSCALL] INT 0x80 interface initialized`
  - Full ring3 syscall-path confirmation still requires interactive `ring3test` in QEMU window.
  - Image sizing remains within cap (`kernel.bin` = 17456 bytes, `os.bin` = 65536 bytes).

## 2026-02-09 12:55:36 +0300 - Post-Task 22 Hardening (Scheduler/TSS and Syscall Gate)
- Completed: Applied follow-up fixes from audit feedback after Task 22 validation.
- `process_refresh_tss_stack()` race fix:
  - `kernel/process.c` now wraps `process_current_index` read + `tss_set_kernel_stack(...)` in `spinlock_irq_save()`/`spinlock_irq_restore()`.
  - This aligns with `process_yield()` scheduler critical-section semantics and prevents TSS `esp0` being refreshed against stale task index under preemption.
- Syscall gate behavior hardening:
  - `kernel/idt.h` added `IDT_GATE_TRAP32_USER` (`0xEF`).
  - `kernel/idt.c` switched vector `0x80` from user interrupt gate to user trap gate.
  - Trap gate preserves `IF`, reducing risk of IRQ starvation/latency spikes during longer syscall handlers.
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU serial smoke boot remains stable through init/scheduler/console path.

## 2026-02-09 12:50:50 +0300 - Codebase Audit (Reviewer Pass 3, post-Task 22)
- Completed: Re-audited Task 21/22 changes (`TSS.esp0` switching + `INT 0x80` syscall path), including scheduler/TSS interactions and syscall entry/return behavior.
- Validation:
  - `make clean && make -j4` passes with `-Wall -Wextra -Werror`.
  - Headless QEMU serial smoke boot reaches stable scheduler + console loop.
  - Automated `ring3test` run via QEMU monitor `sendkey` confirmed:
    - syscall entry marker (`[SYSCALL] first INT 0x80 received`)
    - return value propagation (`EAX=0xFFFFFFFF`, copied to `EBX`)
    - expected post-syscall ring3 `#GP` at user `CS=0x23`.
- Reference docs consulted from `docs/core/`:
  - `System_Calls.md`
  - `Interrupt_Descriptor_Table.md`
  - `Interrupt_Service_Routines.md`
  - `Context_Switching.md`
- Findings captured for follow-up:
  - `process_refresh_tss_stack()` updates `esp0` without an IRQ-safe critical section (can race with scheduler state changes under preemption).
  - Syscall gate uses an interrupt gate (IF cleared for full syscall duration), which can become a latency/deadlock hazard for longer/blocking syscall handlers.
  - Residual pre-existing risks remain: E820 single-entry rejection edge case and PMM free-frame accounting drift on overlapping E820 ranges.

## 2026-02-09 13:00:48 +0300 - Phase 5, Task 23: Basic Syscalls (write, exit, sbrk)
- Completed: Implemented first usable syscall set on top of `INT 0x80`.
- Syscall API updates:
  - `kernel/syscall.h`: added syscall number constants:
    - `SYSCALL_WRITE = 1`
    - `SYSCALL_EXIT = 2`
    - `SYSCALL_SBRK = 3`
  - `kernel/syscall.c`:
    - Added `write(fd, buf, len)` for `fd` 1/2 (stdout/stderr path to VGA+serial).
    - Added `exit(status)` with current safety rule: bootstrap `pid=1` cannot exit (returns error).
    - Added `sbrk(increment)` with per-process break tracking and page map/unmap using PMM+paging.
    - Added user-range + mapped-page validation for user pointers before `write`.
- Process subsystem support for syscall state:
  - `kernel/process.h` / `kernel/process.c`:
    - Added per-process `user_break` field.
    - Added `process_get_current_pid()`.
    - Added `process_terminate_current()` (non-returning helper for syscall exit path).
    - Added per-process break helpers:
      - `process_user_heap_base()`
      - `process_user_heap_limit()`
      - `process_get_current_user_break()`
      - `process_set_current_user_break()`
    - Introduced initial user-heap range constants:
      - base: `0x09000000`
      - limit: `0x0A000000`
- Ring3 probe update for syscall verification:
  - `kernel/usermode.c` ring3 payload now performs:
    - `write(1, "ring3 write ok\\n", 15)`
    - `sbrk(+4096)`
    - `sbrk(-4096)`
    - `exit(0)` (expected to fail for bootstrap task)
    - then executes `cli` to trigger expected ring3 `#GP`.
  - This keeps the existing ring3 proof path while exercising Task 23 syscalls in sequence.
- Reference docs consulted from `docs/core/`:
  - `System_Calls.md`
  - `Task_State_Segment.md`
  - `Context_Switching.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU serial smoke boot (`make run`) reaches stable init/scheduler/console path with no regressions.
  - Interactive `ring3test` confirmation is required in QEMU window to observe:
    - ring3 write output
    - syscall trace + expected final `#GP` in ring3.
  - Image sizing remains within cap (`kernel.bin` = 18640 bytes, `os.bin` = 65536 bytes).

## 2026-02-09 13:12:31 +0300 - Phase 5, Task 24: ELF Loader (Simple Static ELF)
- Completed: Added a minimal ELF32 executable loader that maps PT_LOAD segments into user space and jumps to ELF entry in ring 3.
- New loader module:
  - `kernel/elf.h`
  - `kernel/elf.c`
  - Implements:
    - ELF header validation (magic/class/endianness/type/machine/version)
    - Program header parsing (`PT_LOAD` only)
    - Per-segment user page allocation/mapping and file/bss copy semantics (`p_filesz` + zero-fill to `p_memsz`)
    - Entry-point validation
    - Dedicated user stack mapping for loaded ELF image (`0x0BFF0000` page)
    - Cleanup of newly mapped pages on load failure
- Embedded static ELF test binary:
  - New file `user/elf_demo.asm` (simple static ring3 program using `write`, `sbrk`, `exit`, then intentional `cli` for deterministic end-of-test `#GP`).
  - Build pipeline in `Makefile`:
    - assemble user ELF object
    - link to executable ELF (`build/elf_demo.elf`, entry `0x08048000`)
    - convert ELF file to linkable blob object (`build/elf_demo_blob.o`) via `objcopy`
    - link blob object into kernel image
- Ring3 execution integration:
  - `kernel/usermode.h` / `kernel/usermode.c`: exported reusable `usermode_enter_ring3(entry, esp)` iret transition helper.
  - `kernel/console.c`: added new command `elftest` and updated `help` output.
  - `elftest` path loads embedded ELF and transfers to ELF entry in ring 3.
- Reference docs consulted from `docs/core/`:
  - `ELF.md`
  - `ELF_Tutorial.md`
  - `System_Calls.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - ELF sample inspection (`i686-elf-readelf -h -l build/elf_demo.elf`) confirms valid 32-bit `ET_EXEC` image with one `PT_LOAD` segment and expected entry point.
  - QEMU serial smoke boot (`make run`) reaches stable init/scheduler/console path with no regressions.
  - Interactive `elftest` execution must be run in QEMU window to validate loader jump and user ELF runtime behavior.
  - Image sizing remains within cap (`kernel.bin` = 25408 bytes, `os.bin` = 65536 bytes; embedded `elf_demo.elf` = 4688 bytes).

## 2026-02-09 13:23:56 +0300 - Codebase Audit (Reviewer Pass 4, post-Task 23/24)
- Completed: Re-audited syscall (`write/exit/sbrk`) and embedded ELF loader paths with static review + runtime validation.
- Runtime validation performed:
  - `make -j4` successful with `-Wall -Wextra -Werror`.
  - Headless QEMU run with monitor `sendkey` automation for:
    - `ring3test` (observed syscall path + expected ring3 `#GP`)
    - `elftest` (observed ELF load, syscall activity, and expected ring3 `#GP`)
- Reference docs consulted from `docs/core/`:
  - `System_Calls.md`
  - `ELF.md`
  - `ELF_Tutorial.md`
  - `Paging.md`
  - `Detecting_Memory_(x86).md`
- Findings captured for follow-up:
  - ELF loader does not reconcile permissions for overlapping PT_LOAD pages (can leave writable data page read-only in user mode).
  - Process teardown still does not reclaim user mappings created by `sbrk`/ELF load (future memory/frame leakage risk).
  - Syscall user-pointer validation checks presence but not U/S access bit, leaving a future kernel-memory exposure hazard if supervisor mappings appear below split.
  - ELF loader uses a 4KB on-stack mapped-page scratch array while kernel process stacks are also 4KB, creating stack-overflow risk once loader is used from non-bootstrap process context.
  - Residual pre-existing boot risk remains: stage2 E820 first-call path still fails if BIOS returns a valid single-entry map (`EBX=0`).

## 2026-02-09 13:28:38 +0300 - Post-Task 24 Audit Hotfixes (#1 and #5)
- Completed: Fixed the two requested ELF loader issues from reviewer pass 4.
- Fix #1 (PT_LOAD permission merge for overlapping pages):
  - Added `paging_or_page_flags()` in:
    - `kernel/paging.h`
    - `kernel/paging.c`
  - `kernel/elf.c` now upgrades flags for already-loader-mapped overlap pages when a later segment requires writable access.
  - This prevents valid overlapping RX/RW ELF layouts from leaving data pages read-only.
- Fix #5 (ELF loader stack footprint):
  - Moved ELF mapped-page scratch list off stack:
    - replaced local `uint32_t mapped_pages[1024]` with file-scope loader scratch buffer.
  - Keeps loader within 4KB kernel-stack constraints when invoked outside bootstrap context.
- Deferred by request:
  - #2 and #3 are intentionally postponed and tagged for Task 29/fork+exec audit:
    - user mapping reclamation on process teardown
    - per-process `user_break` correctness relative to global CR3 sharing
- Explicitly not changed in this hotfix round:
  - #4 (U/S-bit pointer hardening) deferred.
  - #6 (E820 single-entry edge case) deferred.
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - QEMU serial smoke boot (`make run`) reaches stable init/scheduler/console path with no regressions.
  - Image sizing remains within cap (`kernel.bin` = 25504 bytes, `os.bin` = 65536 bytes).

## 2026-02-09 13:37:41 +0300 - Phase 6, Task 25: VFS Layer
- Completed: Added an initial VFS core layer with mount-point, vnode, and open-file abstractions.
- New files:
  - `kernel/vfs.h`
  - `kernel/vfs.c`
- VFS core capabilities implemented:
  - Vnode + ops interface (`lookup`, `read`, `write`) with node type metadata.
  - Path normalization and absolute-path resolution across a mount table (longest-prefix mount match).
  - Mount API (`vfs_mount`) with mount replacement on existing mount path.
  - Kernel file-handle API (`vfs_open`, `vfs_read`, `vfs_write`, `vfs_close`) with position tracking.
  - IRQ-safe internal state protection (mount table + open-file table) via spinlock helpers.
  - Default empty root mount at `/` installed during `vfs_init()`.
- Integration:
  - `kernel/kernel.c` now initializes VFS during boot (`vfs_init()`), with VGA/serial status output.
  - `Makefile` now compiles/links `kernel/vfs.c`.
- Reference docs consulted from `docs/core/`:
  - `VFS.md`
  - `Hierarchical_VFS_Theory.md`
  - `File_Systems.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - `make run` reaches stable boot, including `[VFS] initialized`, and continues through scheduler + console initialization.

## 2026-02-09 13:46:28 +0300 - Phase 6, Task 26: initrd / Ramdisk (tar-based)
- Completed: Added a read-only tar-backed initrd filesystem and mounted it on VFS root (`/`) at boot.
- New files:
  - `kernel/initrd.h`
  - `kernel/initrd.c`
  - `initrd/hello.txt`
  - `initrd/etc/motd.txt`
- Implementation details:
  - Embedded initrd archive build pipeline in `Makefile`:
    - create `build/initrd.tar` from `initrd/` using `tar --format=ustar`
    - convert to linkable blob object (`build/initrd_blob.o`) via `objcopy`
    - link blob into kernel image
  - `kernel/initrd.c` implements:
    - USTAR header parsing (including octal size parsing and 512-byte block stepping)
    - in-memory initrd node table (directories + regular files)
    - hierarchical lookup via VFS vnode ops (`lookup`) and read-only file reads (`read`)
    - root mount via `vfs_mount("/")`
  - `kernel/kernel.c` now calls `initrd_init()` immediately after `vfs_init()`.
  - Added boot self-test: open/read `/hello.txt` through VFS and log the content to serial.
- Reference docs consulted:
  - `docs/core/Initrd.md`
  - `docs/library/USTAR.md`
  - `docs/library/Tar.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - `make run` serial output confirms:
    - `[INITRD] mounted tar initrd entries=4`
    - `[INITRD] self-test /hello.txt: Hello from ClaudeOS initrd.`
  - Boot continues through scheduler and console initialization with no regressions.

## 2026-02-09 14:01:43 +0300 - Phase 6, Task 27: FAT32 Read Support via ATA PIO
- Completed: Added ATA PIO sector-read support and a read-only FAT32 filesystem driver mounted through VFS.
- New files:
  - `kernel/ata.h`
  - `kernel/ata.c`
  - `kernel/fat32.h`
  - `kernel/fat32.c`
  - `tools/mkfat32_image.py`
- Implementation details:
  - ATA PIO layer (`kernel/ata.c`):
    - Primary-bus IDENTIFY probing for master/slave drives.
    - 28-bit LBA PIO sector read path (`ata_pio_read28`) with BSY/DRQ polling, status checks, and 400ns delays.
    - IRQ-safe bus serialization using existing spinlock helpers.
  - FAT32 layer (`kernel/fat32.c`):
    - FAT32 BPB parsing and validation (boot sector at partition start).
    - Partition detection supporting both superfloppy FAT32 and MBR FAT32 partition types (`0x0B`, `0x0C`).
    - Directory traversal via 8.3 entries (LFN skipped), cluster-chain walking via FAT table, and file reads across cluster boundaries.
    - Mounted at `/fat` via VFS node ops.
  - Host-side deterministic FAT32 test image:
    - `tools/mkfat32_image.py` generates `build/fat32.img` (64MiB FAT32 superfloppy) with:
      - `/HELLO.TXT`
      - `/DOCS/INFO.TXT`
  - Build/run integration (`Makefile`):
    - Added ATA/FAT32 kernel objects.
    - Added FAT32 image build target.
    - `make run` now attaches the FAT32 image as a second IDE disk.
  - Minor I/O support extension:
    - `kernel/io.h` now provides `inw`/`outw` helpers for ATA PIO word transfers.
- Kernel integration:
  - `kernel/kernel.c` now runs `fat32_init()` after VFS/initrd setup and reports mount status on VGA.
- Reference docs consulted:
  - `docs/core/ATA_PIO_Mode.md`
  - `docs/core/ATA_read_write_sectors.md`
  - `docs/core/FAT.md`
  - `docs/core/FAT32.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - `make run` confirms:
    - ATA probe (`primary master` + `primary slave`)
    - FAT32 mounted at `/fat`
    - Read self-tests passed:
      - `[FAT32] self-test /fat/HELLO.TXT: Hello from ClaudeOS FAT32 via ATA PIO.`
      - `[FAT32] self-test /fat/DOCS/INFO.TXT: Subdirectory read path works.`
  - Boot continues through scheduler + console path without regressions.

## 2026-02-09 14:19:55 +0300 - Phase 6, Task 28: Syscalls (`open`, `close`, `read`)
- Completed: Added user-visible `open`, `read`, and `close` syscalls on top of VFS.
- Files updated:
  - `kernel/syscall.h`
  - `kernel/syscall.c`
  - `user/elf_demo.asm`
- Syscall ABI additions:
  - `SYSCALL_OPEN = 4`
  - `SYSCALL_READ = 5`
  - `SYSCALL_CLOSE = 6`
  - open flags:
    - `SYSCALL_O_READ = 0x1`
    - `SYSCALL_O_WRITE = 0x2`
- Kernel syscall implementation details:
  - Added user C-string copy/validation helper for path arguments (`open`).
  - `open(path, flags)`:
    - validates user path pointer/mapping
    - maps syscall flags to VFS flags
    - dispatches to `vfs_open`
  - `read(fd, buf, len)`:
    - validates user buffer mapping/range
    - dispatches to `vfs_read`
  - `close(fd)`:
    - dispatches to `vfs_close`
  - Return contract remains simple and stable for this phase:
    - success: non-negative values
    - failure: `-1` (`0xFFFFFFFF`)
- Embedded user ELF test update:
  - `user/elf_demo.asm` now exercises Task 28 path:
    - `sbrk(+4096)` for temporary user buffer
    - `open("/fat/HELLO.TXT", O_READ)`
    - `read(fd, buffer, 128)`
    - `write(1, buffer, bytes_read)`
    - `close(fd)`
    - `sbrk(-4096)`
    - existing `exit` + intentional ring3 `cli` (expected `#GP`) retained for deterministic test termination.
- Reference docs consulted:
  - `docs/core/System_Calls.md`
  - `docs/core/VFS.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - Automated `elftest` run via QEMU monitor `sendkey` confirmed:
    - syscall path reaches ring3 ELF (`[ELF] loaded embedded ELF (ring3 jump)`)
    - user-space `open/read/close` succeeds and prints FAT32 file contents from ring3:
      - `Hello from ClaudeOS FAT32 via ATA PIO.`
    - test ends with the expected ring3 `#GP` (intentional `cli`), preserving prior validation behavior.

## 2026-02-09 14:37:38 +0300 - Phase 6, Task 29: Basic `fork` + `exec`
- Completed: Added baseline `fork`/`exec` syscalls and an end-to-end ring3 validation flow.
- Syscall API updates:
  - `kernel/syscall.h`: added
    - `SYSCALL_FORK = 7`
    - `SYSCALL_EXEC = 8`
  - `kernel/syscall.c`:
    - `fork()` now creates a child kernel process that performs a user-image load from the caller's recorded image path and enters ring3.
    - `exec(path)` loads a new ELF image from VFS and transitions the current process to that user entry point.
    - Added process image-path plumbing and child exec context handling for fork path.
- Process metadata updates:
  - `kernel/process.h` / `kernel/process.c`:
    - Added per-process `user_image_path` state.
    - Added:
      - `process_get_current_image_path()`
      - `process_set_current_image_path()`
- ELF/runtime integration:
  - `kernel/elf.c` / `kernel/elf.h`:
    - Added VFS ELF loader helper: `elf_load_user_image_from_vfs()`.
    - Added embedded ring3 probe `elf_run_fork_exec_test()` for Task 29.
    - Added loader serialization lock around `elf_load_user_image()` to avoid concurrent loader scratch/global-mapping races during preemptive scheduling.
    - `elf_run_embedded_test()` now records current user image path (`/elf_demo.elf`) for fork compatibility.
  - `kernel/console.c`:
    - Added `forkexec` command and updated `help`.
- Build/initrd integration:
  - Added `user/fork_exec_demo.asm` embedded user probe binary.
  - `Makefile` now builds `fork_exec_demo.elf` and embeds it in kernel.
  - `Makefile` now stages initrd content through `build/initrd_root/` and injects `build/elf_demo.elf` as `/elf_demo.elf` so `exec`/fork-child image loads can resolve via VFS.
- Reference docs consulted from `docs/core/`:
  - `System_Calls.md`
  - `ELF.md`
  - `Kernel_Multitasking.md`
  - `Processes_and_Threads.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - Headless QEMU `sendkey` automation for `forkexec` confirms:
    - console dispatch (`[CONSOLE] forkexec`)
    - fork child creation (`[PROC] Created kernel process pid=... name=fork_user`)
    - child exec handoff (`[PROC] fork child entering user image`)
    - parent exec handoff into `/elf_demo.elf` syscall path (`[ELF] hello from embedded user ELF`)
    - expected ring3 terminal `#GP` from bootstrap-path user ELF test.
- Scope note:
  - Current `fork()` is intentionally basic (spawn-like) under the shared-CR3 model; full POSIX-style address-space clone semantics are deferred with Task 29 follow-up audit items (`user mapping reclamation` and `per-process address-space isolation`).

## 2026-02-09 14:48:15 +0300 - Audit pass for Phase 6 Tasks 28-29
- Completed:
  - Performed a focused reviewer audit of Task 28/29 changes (`open/read/close`, `fork/exec`) with code-level line checks and runtime spot validation.
  - Re-checked syscall, process, ELF loader, VFS, and ATA interactions for correctness under preemption.
- Reference docs consulted:
  - `docs/core/System_Calls.md`
  - `docs/core/Loading_a_Process.md`
  - `docs/core/Processes_and_Threads.md`
- High-priority findings (reported to user with file/line references):
  - `process_create_kernel()` mutates PCB globals without scheduler/PCB locking, enabling fork-time races under trap-gate syscall preemption.
  - `exec`/ELF load path can destroy previous user mappings before load success is guaranteed, making failed `exec` non-atomic.
  - Shared address-space model (`cr3` never switched in context switch) remains incompatible with concurrent `fork`/`exec` expectations and per-process heap/accounting assumptions.
- Future-headache findings:
  - Global VFS FD table has no per-process ownership and no close-on-exit cleanup path.
  - Long VFS/FAT32/ATA read paths execute with IRQs disabled due nested `spinlock_lock_irqsave` usage, risking interrupt latency spikes.

## 2026-02-10 21:20:00 +0300 - Audit pass for newly completed Tasks 35-39
- Completed:
  - Reviewed the new graphics/input/libc milestones landed after `fa68410`:
    - Task 35 (VBE bootstrap + LFB mapping)
    - Task 36 (framebuffer primitives + console backend)
    - Task 37 (PS/2 mouse IRQ12 driver)
    - Task 38 (basic stacking window manager)
    - Task 39 (libc expansion for DOOM prerequisites)
  - Rebuilt from clean (`make clean && make -j4`) and ran runtime checks:
    - `bash tools/run_task34_demo.sh` (PASS)
    - headless `wmstart`/`q` QEMU monitor scenario (WM start/stop markers observed in serial log).
- Reference docs consulted:
  - `docs/core/VESA_Video_Modes.md`
  - `docs/core/Drawing_In_a_Linear_Framebuffer.md`
  - `docs/core/PS_2_Mouse.md`
  - `docs/core/C_Library.md`
- Main findings captured for user report:
  - `stdio` path persistence is shorter than kernel VFS path limit; `fseek`/`rewind` reopen logic can fail or reopen wrong files for long paths.
  - `fopen` mode parsing currently does not implement `w` truncate or `a` append semantics; this is a compatibility trap when write-capable filesystems arrive.
  - Framebuffer pixel packing assumes fixed BGR/RGB565 layouts and ignores VBE mask/position metadata.
  - Mouse command-ACK reads are not filtered to AUX-origin bytes.
  - `syscall_write` now holds IRQ-off lock across full buffer writes, creating interrupt-latency risk for large writes.

## 2026-02-09 14:58:00 +0300 - Task 29 Isolation Hardening (Post-Audit Fix)
- Completed: Fixed the shared-address-space isolation gap reported for Task 29.
- Process/address-space updates (`kernel/process.c`, `kernel/process.h`):
  - Added per-process page-directory ownership tracking (`owns_address_space`).
  - Added per-process address-space creation on process creation:
    - allocates a dedicated page directory frame
    - copies kernel-half PDEs
    - installs recursive PDE mapping for the new CR3
  - Added address-space teardown on process slot release:
    - frees user-half mappings/page tables for terminated tasks
    - frees page-directory frame
  - Scheduler now performs CR3 context switching in `process_yield()` before stack switch when next process has a different address space.
- ELF loader bookkeeping updates (`kernel/elf.c`, `kernel/elf.h`):
  - Replaced global active-page tracking with per-address-space tracking keyed by CR3.
  - Added `elf_forget_address_space(cr3)` and wired it into process teardown to avoid stale loader metadata across CR3 reuse.
- Reference docs consulted from `docs/core/`:
  - `Context_Switching.md`
  - `Paging.md`
  - `Task_State_Segment.md`
- Verified:
  - `make -j4` builds cleanly with `-Wall -Wextra -Werror`.
  - Headless QEMU `sendkey` regressions:
    - `elftest` still loads/runs user ELF and reaches expected terminal ring3 `#GP`.
    - `forkexec` still creates child process and runs user-mode path, reaching expected terminal ring3 `#GP`.
- Note:
  - This addresses Task 29 isolation semantics at the page-directory level (CR3-per-process).
  - Full POSIX `fork` copy-on-write semantics and per-process FD ownership remain future work.

## 2026-02-09 15:07:23 +0300 - Post-Audit Bugfixes (fork/exec + VFS lifecycle)
- Completed: Fixed three reported correctness risks in process creation, exec failure behavior, and file-descriptor lifecycle.
- Fix 1: `fork()` PCB race under preemption
  - `kernel/process.c` now guards `process_create_kernel()` with an IRQ-safe creation lock.
  - This serializes free-slot/PID assignment and address-space construction so timer preemption cannot interleave two concurrent forks into the same PCB metadata path.
- Fix 2: `exec()` load failure rollback
  - `kernel/elf.c` now tracks replaced old mappings during load and restores them on failure before returning.
  - Added page-flag query helper in paging layer:
    - `kernel/paging.h`
    - `kernel/paging.c` (`paging_get_page_flags`)
  - Result: failed ELF load no longer tears down the previous runnable image mappings.
- Fix 3: global FD lifecycle leakage/interference
  - `kernel/vfs.c` now records `owner_pid` per open file, enforces owner access on `read/write/close`, and exposes `vfs_close_owned_by_pid(pid)`.
  - `kernel/process.c` now calls `vfs_close_owned_by_pid` on process slot release.
  - `kernel/vfs.h` updated with the cleanup API.
- Reference docs consulted from `docs/core/`:
  - `System_Calls.md`
  - `Context_Switching.md`
  - `Paging.md`
  - `Processes_and_Threads.md`
- Verified:
  - `make -j4` passes with `-Wall -Wextra -Werror`.
  - Headless QEMU monitor-driven regressions pass:
    - `elftest` still runs and prints FAT32 file contents.
    - `forkexec` still spawns child + exec path, and both user flows reach expected terminal ring3 `#GP`.

## 2026-02-09 16:05:47 +0300 - Phase 7, Task 30: Basic Userspace libc
- Completed: Added a minimal userspace libc and a C smoke-test user program.
- New userspace libc files:
  - `user/libc/include/unistd.h`, `user/libc/include/stdio.h`, `user/libc/include/stdlib.h`, `user/libc/include/string.h`
  - `user/libc/syscall.c` (INT 0x80 wrappers for `write/open/read/close/fork/exec/sbrk/exit`)
  - `user/libc/stdio.c` (`putchar`, `puts`, small `printf` with `%s/%c/%d/%u/%x/%%`)
  - `user/libc/string.c` (`strlen`, `strcmp`, `strncmp`, `strcpy`, `memcpy`, `memmove`, `memset`)
  - `user/libc/malloc.c` (simple `sbrk`-backed free-list allocator)
  - `user/libc/crt0.asm` (`_start -> main -> exit`)
- Added `user/libctest.c` smoke test covering:
  - libc `printf`
  - libc `malloc/free` + string ops
  - syscall-backed file I/O (`open/read/close`) against `/fat/HELLO.TXT`
- Kernel/runtime integration:
  - `kernel/console.c`: added `libctest` command and help text update.
  - `kernel/elf.c` / `kernel/elf.h`: added `elf_run_libc_test()`.
  - `libctest` now runs in a spawned kernel process (pid != 1), so libc `exit()` can terminate cleanly without stalling the bootstrap task.
- Build/integration updates (`Makefile`):
  - Added build/link chain for libc objects + `libctest.elf`.
  - Added `libctest.elf` into initrd staging (`build/initrd_root/libctest.elf`).
  - Added `Makefile` as dependency of `mbr.bin`/`stage2.bin` so `KERNEL_MAX_SECTORS` changes force bootloader rebuilds.
- Issue encountered and resolved:
  - Increasing `KERNEL_MAX_SECTORS` too high caused boot failure because current MBR two-chunk INT13 extension reads exceeded BIOS request limits.
  - Set `KERNEL_MAX_SECTORS` to `190` (safe with current `65 + 127` split) and kept larger fixed image padding (`OS_IMAGE_SIZE=262144`) for headroom.
- Reference docs consulted:
  - `docs/core/C_Library.md`
  - `docs/core/System_Calls.md`
  - `docs/core/ELF.md`
- Verified:
  - `make clean && make -j4` passes with `-Wall -Wextra -Werror`.
  - Headless QEMU boot smoke (`-display none -serial file`) confirms no regressions in PMM/VFS/initrd/FAT32/scheduler init.
  - Headless QEMU monitor `sendkey` test (`-monitor stdio`) for `libctest` confirms:
    - `[CONSOLE] libctest`
    - `[ELF] spawned libc test process`
    - `[LIBC] user C program started`
    - `[LIBC] malloc+string ready (len=26)`
    - `[LIBC] read bytes=39`
    - `Hello from ClaudeOS FAT32 via ATA PIO.`
    - Console remains responsive afterward (`help` still works).
  - Regression spot checks (headless `sendkey`) confirm `elftest` and `forkexec` still behave as before.

## 2026-02-09 16:17:08 +0300 - Phase 7, Task 31: Shell as a Userspace Process
- Completed: Added an initial userspace shell binary (`/shell.elf`) and integrated it with kernel console launch flow.
- Userspace shell implementation:
  - New file: `user/shell.c`
  - Behavior:
    - prints shell banner/prompt lines from ring3
    - demonstrates shell-style command flow (`help`, `cat /fat/HELLO.TXT`, `cat /etc/motd.txt`, `exit`)
    - uses libc + syscall wrappers (`open/read/write/close/exit`) as a userspace process
- Kernel integration:
  - `kernel/console.c`: added `shell` command and updated help output
  - `kernel/elf.c` / `kernel/elf.h`: added `elf_run_shell()` and generalized VFS-user-image spawn helper for shell/libctest
- Build/initrd updates (`Makefile`):
  - Added `user/shell.c` build/link path to produce `build/shell.elf`
  - Added `shell.elf` to initrd staging (`build/initrd_root/shell.elf`)
  - Added user ELF link stripping (`-s`) and removed debug info from user C flags (`USER_CFLAGS` without `-g`) to keep image size within current bootloader sector cap
  - Moved initrd stamp file outside tar root (`build/initrd_root.stamp`) to avoid packing a synthetic `/.stamp` entry into initrd
- Issue encountered and resolved:
  - Initial Task 31 integration exceeded current kernel image cap by 292 bytes (`97572 > 97280`) due extra initrd payload.
  - Fixed by removing stamp-entry tar overhead and stripping user ELFs; build now fits without changing boot read chunking.
- Reference docs consulted:
  - `docs/core/Creating_A_Shell.md`
  - `docs/core/Terminals.md`
  - `docs/core/C_Library.md`
- Verified:
  - `make -j4` succeeds.
  - Headless QEMU `sendkey` test for `shell` confirms:
    - `[CONSOLE] shell`
    - `[ELF] spawned userspace shell`
    - `[SHELL] ClaudeOS userspace shell started`
    - shell reads and prints `/fat/HELLO.TXT` and `/etc/motd.txt`
    - kernel console remains responsive after shell exits (`help` still works).
  - Regressions:
    - `libctest` still runs successfully.
    - `elftest` still reaches expected terminal ring3 `#GP`.

## 2026-02-09 16:32:16 +0300 - Phase 7, Task 32: Shell Builtins (`ls`, `cat`, `echo`, `clear`, `help`, `ps`)
- Completed: Implemented Task 32 builtins inside userspace shell command dispatcher.
- Files updated:
  - `user/shell.c`:
    - added command parsing/tokenization and builtin dispatch
    - implemented builtins:
      - `help`
      - `echo`
      - `clear` (newline-based terminal clear behavior)
      - `cat <path>`
      - `ls [path]` (supported for `/`, `/etc`, `/fat`, `/fat/DOCS`)
      - `ps`
      - `exit`
    - shell now runs a deterministic builtin script to validate behavior end-to-end in the current no-stdin environment.
  - `kernel/syscall.h`, `kernel/syscall.c`:
    - added `SYSCALL_GETPID` and `SYSCALL_PCOUNT` for shell `ps` builtin
  - `user/libc/include/unistd.h`, `user/libc/syscall.c`:
    - added libc wrappers for `getpid()` and `proc_count()`
- Scope note:
  - Interactive stdin is still pending; builtins are executed via scripted command sequence in this phase.
  - This keeps work scoped to Task 32 without introducing a new input syscall path.
- Reference docs consulted:
  - `docs/core/Creating_A_Shell.md`
  - `docs/core/Terminals.md`
  - `docs/core/System_Calls.md`
- Verified:
  - `make -j4` passes with `-Wall -Wextra -Werror`.
  - Headless QEMU `sendkey` run for `shell` confirms builtin behavior:
    - `help` prints builtin list
    - `echo` prints arguments
    - `ls` lists supported paths
    - `cat` reads both initrd and FAT32 files
    - `ps` prints current PID + total process count
    - `clear` emits expected line clear behavior
    - `exit` returns control to kernel console
  - Regression checks:
    - `libctest` still passes.
    - `elftest` still reaches expected terminal ring3 `#GP`.

## 2026-02-09 16:49:25 +0300 - Phase 7, Task 33: Standalone Userspace Programs
- Completed: Added 3 standalone ring3 ELF programs and integrated launch commands from the kernel console.
- New userspace programs:
  - `user/uhello.asm`:
    - simple `write` + `exit` demo (`/uhello.elf`)
  - `user/ucat.asm`:
    - standalone file-read demo (`open/read/close` on `/fat/HELLO.TXT`) (`/ucat.elf`)
  - `user/uexec.asm`:
    - `exec("/uhello.elf")` chain demo (`/uexec.elf`)
- Build/initrd integration (`Makefile`):
  - added assembly+link rules for `uhello.elf`, `ucat.elf`, `uexec.elf`
  - staged all three binaries into initrd root:
    - `/uhello.elf`
    - `/ucat.elf`
    - `/uexec.elf`
- Kernel launch integration:
  - `kernel/elf.c`, `kernel/elf.h`:
    - added:
      - `elf_run_uhello()`
      - `elf_run_ucat()`
      - `elf_run_uexec()`
      - `elf_run_apps_demo()`
  - `kernel/console.c`:
    - added commands:
      - `uhello`
      - `ucat`
      - `uexec`
      - `appsdemo`
    - updated `help` output accordingly
- Shell polish:
  - `user/shell.c` root listing now includes `uhello.elf`, `ucat.elf`, and `uexec.elf` when present.
- Reference docs consulted:
  - `docs/core/System_Calls.md`
  - `docs/core/Loading_a_Process.md`
  - `docs/core/Creating_A_Shell.md`
- Verified:
  - `make -j4` passes with `-Wall -Wextra -Werror`.
  - Headless QEMU monitor `sendkey` run (`build/serial_task33_apps.log`) confirms:
    - `uhello` prints standalone message
    - `ucat` reads and prints FAT32 `HELLO.TXT`
    - `uexec` execs into `uhello`
    - `appsdemo` launches all 3 successfully
- Regression check (`build/serial_task33_regression.log`) confirms:
  - `libctest` still passes
  - `shell` still runs and now lists the three new standalone ELFs in `ls /`

## 2026-02-09 16:53:52 +0300 - Phase 7, Task 34: Polish, Test, Demo Script
- Completed: Added a reproducible headless demo/test script and integrated it into the build workflow.
- New tooling:
  - `tools/run_task34_demo.sh`
    - boots QEMU headless with serial-to-file logging
    - drives console commands via QEMU monitor `sendkey`:
      - `help`
      - `libctest`
      - `shell`
      - `uhello`
      - `ucat`
      - `uexec`
      - `appsdemo`
    - validates required serial markers and exits non-zero on mismatch
- Build integration:
  - `Makefile`:
    - added `TASK34_DEMO_SCRIPT` variable
    - added `demo` phony target
    - `make demo` now runs the full scripted scenario and assertions
- Issues encountered and fixed:
  - Initial script version sent literal `echo sendkey ...` strings to QEMU monitor; corrected to emit raw `sendkey` commands.
- Reference docs consulted:
  - `docs/core/Kernel_Debugging.md`
  - `docs/core/System_Calls.md`
  - `docs/core/Creating_A_Shell.md`
- Verified:
  - `make demo` passes end-to-end.
  - Marker checks pass for libc/shell/standalone apps flows.
  - Current artifact sizes:
    - `build/kernel.bin`: `95092` bytes (within `KERNEL_MAX_BYTES=97280`)
    - `build/initrd.tar`: `43520` bytes
    - `build/os.bin`: `262144` bytes

## 2026-02-09 17:02:02 +0300 - Post-Phase 7 Bug Audit (Full-Pass Review)
- Completed: Ran a bug-focused full-pass audit across boot, PMM/paging, scheduler/process, syscall/user-memory validation, VFS/FAT32/ATA, and userspace shell/libc integration.
- Validation steps:
  - static line-by-line review of high-risk paths
  - reran `make demo` to confirm Task 34 scripted flow remains green
- Findings logged for follow-up:
  - IRQ-off lock scope in VFS/FAT32/ATA I/O path can create large interrupt latency windows.
  - Syscall user-pointer validation still checks page presence only (not U/S access bits).
  - PMM free-frame accounting can drift on overlapping usable E820 ranges.
  - Stage2 E820 first-call handling is still strict on `EBX==0` edge case.
  - Kernel entry BSS zeroing still ignores non-dword tail bytes.
  - Keyboard init ACK warning path still misses read-timeout/read-failure diagnostics.

## 2026-02-09 17:02:02 +0300 - Docs Core Sync for New Phases (GUI + DOOM)
- Completed: Checked `AGENTS.md` new Phase 8/9 tasks against `docs/core` coverage and copied missing relevant OSDev articles from `docs/library` into `docs/core`.
- Added to `docs/core`:
  - `GUI.md`
  - `Compositing.md`
  - `Double_Buffering.md`
  - `Graphics_stack.md`
  - `How_do_I_set_a_graphics_mode.md`
  - `PC_Screen_Font.md`
  - `Mouse.md`
  - `Mouse_Input.md`
  - `PS_2_Mouse.md`
  - `PS2_Mouse.md`
  - `Cross-Porting_Software.md`
  - `Portability.md`
  - `Sound.md`
  - `Sound_Blaster_16.md`
- Note:
  - Core already had major prerequisites for these phases (`VBE`, framebuffer, paging, PIT/timers, libc/memory docs).
  - Repository currently has `/docs` in `.gitignore`; these files are present locally but ignored by git until that rule is removed.

## 2026-02-10 19:09:38 +0300 - Phase 8/9 Doc Readiness Pass (Focused Read)
- Completed: Read and distilled the highest-impact docs for upcoming implementation work.
- Key references read:
  - `docs/core/VESA_Video_Modes.md`
  - `docs/core/Drawing_In_a_Linear_Framebuffer.md`
  - `docs/core/Double_Buffering.md`
  - `docs/core/GUI.md`
  - `docs/core/PC_Screen_Font.md`
  - `docs/core/I8042_PS_2_Controller.md`
  - `docs/core/PS_2_Mouse.md`
  - `docs/core/Mouse_Input.md`
  - `docs/core/C_Library.md`
  - `docs/core/Creating_a_C_Library.md`
  - `docs/core/Cross-Porting_Software.md`
  - `docs/core/Portability.md`
  - `docs/core/Sound.md`
- Important implementation constraints captured:
  - VBE setup must happen pre-protected mode (stage2 real mode), with AX checks expecting `0x004F` for each `INT 0x10` VBE call.
  - Mode selection should query mode list (`0x4F00` + `0x4F01`) and set graphics mode with LFB bit (`mode | 0x4000`) via `0x4F02`.
  - Framebuffer address from VBE mode info is physical and must be explicitly mapped in paging; rendering must use `pitch`/`bytes_per_scanline`, not `width * bytes_per_pixel` assumptions.
  - Phase 8 rendering path should default to back-buffer composition and front-buffer blit to avoid visible tearing/flicker and reduce VRAM write churn.
  - PS/2 mouse bring-up should follow controller-safe sequence (`0xA8`, config byte IRQ12 enable, `0xD4`-prefixed device commands, ACK handling) and decode signed 9-bit X/Y deltas from packet byte 1 sign bits.
  - For Phase 9 growth, keep libc separation clear (kernel freestanding vs userspace hosted assumptions), preserve clean syscall ABI, and keep cross-porting workflow sysroot/pkg-config/DESTDIR-driven.
- Issue encountered:
  - `docs/core/VBE.md` and `docs/core/Getting_VBE_Mode_Info.md` are redirect stubs; detailed guidance is in `docs/core/VESA_Video_Modes.md`.

## 2026-02-10 19:25:12 +0300 - Phase 8, Task 35: VBE Framebuffer Setup + Kernel LFB Mapping
- Completed: Implemented VBE graphics-mode bootstrap in stage2 (real mode) and mapped the linear framebuffer into kernel virtual space.
- Bootloader updates:
  - `boot/stage2.asm`:
    - added `setup_vbe` flow using BIOS VBE calls:
      - `INT 0x10, AX=0x4F00` (controller presence check)
      - `INT 0x10, AX=0x4F01` (mode info for target mode `0x118`)
      - `INT 0x10, AX=0x4F02` (set mode with LFB bit, `mode | 0x4000`)
    - exports compact VBE boot info at physical `0x1000` (later visible at `0xC0001000`).
    - stage2 size expanded from 2 sectors to 4 sectors (`STAGE2_SECTORS`) to fit VBE logic.
    - added runtime GDT rebuild (`setup_runtime_gdt`) and removed BIOS teletype calls after `lgdt` to avoid GDTR clobber during graphics BIOS paths.
  - `boot/mbr.asm`:
    - now receives `STAGE2_SECTORS` from build.
    - strengthened disk-read path to split into up to 3 INT13-extensions packet reads so no packet exceeds 127 sectors.
- Kernel updates:
  - new module: `kernel/vbe.c`, `kernel/vbe.h`
    - reads stage2 handoff (`0xC0001000`), validates magic/status, computes framebuffer size.
    - maps framebuffer physical range into kernel MMIO window at `0xD0000000` via `paging_map_page`.
    - exposes runtime getters for upcoming framebuffer console/window manager tasks.
    - logs active VBE mode metadata to serial.
  - `kernel/kernel.c`: invokes `vbe_init()` after `pmm_init()`.
  - `Makefile`:
    - added build wiring for `kernel/vbe.c`.
    - added shared `STAGE2_SECTORS := 4` and passes it to NASM for both MBR and stage2.
- Issues encountered and resolved:
  - Stage2 expansion initially caused bootloader disk-read failure (`Disk err`) because second packet became 129 sectors (>127). Fixed by splitting read into a third chunk.
  - Initial VBE bring-up caused GP fault on real→protected jump due BIOS calls clobbering GDTR state after `lgdt`. Fixed by rebuilding runtime GDT post-VBE and avoiding BIOS calls after `lgdt`.
- Reference docs consulted:
  - `docs/core/VESA_Video_Modes.md`
  - `docs/core/Drawing_In_a_Linear_Framebuffer.md`
  - `docs/core/How_do_I_set_a_graphics_mode.md`
  - `docs/core/Double_Buffering.md`
- Verified:
  - `make -j4` succeeds.
  - Headless QEMU boot (`-display none`, serial-to-file) reaches full kernel init with VBE log:
    - `[VBE] mode=0x00000118 1024x768x24 pitch=3072 fb_phys=0xFD000000 fb_virt=0xD0000000`
  - `make demo` passes regression checks.

## 2026-02-10 20:23:59 +0300 - Phase 8, Task 36: Graphics Primitives + Framebuffer Console
- Completed: Added a double-buffered framebuffer backend with pixel/rect primitives and integrated it under the existing `vga_*` API as the active console path when VBE is available.
- New module:
  - `kernel/fb.c`, `kernel/fb.h`
    - `fb_init()` initializes from `vbe_get_mode()` and creates a back buffer via `kmalloc`.
    - primitive ops:
      - `fb_put_pixel()`
      - `fb_fill_rect()`
      - `fb_clear()`
      - `fb_swap_buffers()`
    - supports 16/24/32bpp pixel write formats.
    - text console layer:
      - 8x16 bitmap glyph rendering (8x8 glyph rows doubled vertically)
      - cursor tracking, newline/tab/backspace behavior, scrolling
      - color mapping from VGA 16-color palette to RGB.
- Console integration:
  - `kernel/vga.c` rewritten as a dual backend:
    - framebuffer-backed console when `fb_init()` succeeds
    - legacy VGA text-mode backend retained as fallback.
  - `kernel/kernel.c` init order adjusted so `kheap_init()` runs before `vga_init()` (framebuffer back-buffer allocation requires heap).
- Build updates:
  - `Makefile`:
    - added `kernel/fb.c` build wiring.
    - increased `KERNEL_MAX_SECTORS` from `190` to `240` after kernel growth from Task 36 exceeded prior image cap.
- Performance issue encountered and fixed:
  - Initial implementation copied the full framebuffer on every character draw, which slowed boot enough to break scripted demo timing.
  - Fixed by adding dirty-rectangle tracking and partial front-buffer blits in `fb_swap_buffers()`.
- Reference docs consulted:
  - `docs/core/Drawing_In_a_Linear_Framebuffer.md`
  - `docs/core/Double_Buffering.md`
  - `docs/core/PC_Screen_Font.md`
- Verified:
  - `make -j4` succeeds.
  - headless serial boot shows framebuffer backend activation:
    - `[FB] initialized 1024x768 bpp=24 pitch=3072`
    - `[VGA] framebuffer console active`
  - `make demo` passes end-to-end regression checks.

## 2026-02-10 20:32:15 +0300 - Phase 8, Task 37: PS/2 Mouse Driver (IRQ12)
- Completed: Added a PS/2 mouse driver with IRQ12 packet handling and kernel-visible mouse state/event APIs.
- New module:
  - `kernel/mouse.c`, `kernel/mouse.h`
    - controller/device bring-up sequence for auxiliary PS/2 port:
      - read/update controller config (`0x20`/`0x60`) to enable IRQ12 and second-port clock
      - enable second port (`0xA8`)
      - send mouse commands via `0xD4` prefix:
        - `0xF6` (set defaults)
        - `0xF4` (enable data reporting)
    - IRQ12 handler decodes standard 3-byte mouse packets.
    - packet resynchronization using first-byte sync bit and overflow-bit discard.
    - signed 9-bit X/Y delta reconstruction.
    - non-blocking event queue + state snapshot API:
      - `mouse_read_event()`
      - `mouse_get_state()`
      - `mouse_is_initialized()`
- Integration:
  - `kernel/kernel.c`:
    - added `mouse_init()` during boot.
    - VGA status line now reports whether mouse init succeeded.
  - `Makefile`:
    - added `kernel/mouse.c` compile rule and object link-in.
- Reference docs consulted:
  - `docs/core/PS_2_Mouse.md`
  - `docs/core/I8042_PS_2_Controller.md`
  - `docs/core/Mouse_Input.md`
- Verified:
  - `make -j4` succeeds with `-Wall -Wextra -Werror`.
  - serial boot now includes:
    - `[MOUSE] PS/2 mouse initialized (IRQ12, 3-byte packets)` on successful init.

## 2026-02-10 20:43:40 +0300 - Phase 8, Task 38: Basic Window Manager
- Completed: Added a basic in-kernel window manager in framebuffer mode with stacking windows, title bars, event dispatch, and title-bar dragging.
- New module:
  - `kernel/wm.c`, `kernel/wm.h`
    - desktop compositor loop built on existing framebuffer back buffer.
    - maintains z-order list for up to 8 windows.
    - pointer event dispatch pipeline (`move/down/up/focus/drag-start/drag-move/drag-end`) to per-window handlers.
    - click-to-focus + bring-to-front behavior.
    - title-bar drag mechanics with screen-bound clamping.
    - simple software cursor rendering.
    - demo window set (3 overlapping windows) for immediate interaction.
- Framebuffer enhancements:
  - `kernel/fb.c`, `kernel/fb.h`
    - added generic pixel-text helpers for GUI overlays:
      - `fb_draw_char()`
      - `fb_draw_text()`
- Console/kernel integration:
  - `kernel/console.c`, `kernel/console.h`
    - added `wmstart` command.
    - help output now documents WM launch and `q` exit behavior.
    - added `console_show_prompt()` helper for prompt restore after WM exit.
  - `kernel/kernel.c`
    - initializes WM subsystem after mouse init.
    - runs `wm_update()` in main loop while WM mode is active.
    - captures `q` key in WM mode to stop WM and return to console prompt.
  - `Makefile`
    - added `kernel/wm.c` build + link wiring.
- Reference docs consulted:
  - `docs/core/GUI.md`
  - `docs/core/Compositing.md`
  - `docs/core/Double_Buffering.md`
  - `docs/core/Mouse_Input.md`
- Verified:
  - `make -j4` passes.
  - headless QEMU run (`build/serial_task38_wm.log`) confirms lifecycle markers:
    - `[WM] initialized 1024x768 windows=3`
    - `[WM] started (drag title bars with mouse, press q to exit)`
    - `[WM] stopped`
  - `make demo` regression script still passes end-to-end.

## 2026-02-10 21:01:43 +0300 - Phase 9, Task 39: libc Expansion for DOOM Bring-up
- Completed: Expanded userspace libc with formatter APIs, stdio file APIs, stronger heap APIs, and additional string/memory routines needed for upcoming DOOM porting.
- `stdio` expansion (`user/libc/include/stdio.h`, `user/libc/stdio.c`):
  - added printf-family support:
    - `vprintf`, `fprintf`, `vfprintf`
    - `sprintf`, `snprintf`, `vsprintf`, `vsnprintf`
  - implemented lightweight `FILE` abstraction with stream table and std streams (`stdin/stdout/stderr`).
  - added file APIs:
    - `fopen`, `fread`, `fwrite`, `fclose`, `fflush`
    - `fseek`, `ftell`, `rewind`, `feof`, `ferror`
  - mode parsing supports `r`, `w`, `a`, `+`, `b` combinations.
  - seek implementation includes reopen+skip fallback (works with current syscall surface that has no dedicated `lseek` syscall yet).
- `malloc` expansion (`user/libc/include/stdlib.h`, `user/libc/malloc.c`):
  - allocator metadata upgraded to doubly-linked free list.
  - added:
    - `calloc`
    - `realloc`
  - improved block split/coalesce logic and top-of-heap release behavior.
- `string` expansion (`user/libc/include/string.h`, `user/libc/string.c`):
  - added:
    - `strncpy`, `strcat`, `strncat`, `strchr`, `strrchr`
    - `memcmp`
- Validation app update (`user/libctest.c`):
  - now exercises `realloc`, `sprintf`, `fopen`/`fread`/`fclose`, and `fseek`/`ftell`/`rewind`.
  - preserves existing Task 34 markers and output expectations.
- Stability fixes found during bring-up:
  - fixed allocator tail-release bug (accessing freed header memory after `sbrk` shrink) in `user/libc/malloc.c`.
  - fixed first-call `puts` initialization bug (stdout pointer evaluated before stream init) in `user/libc/stdio.c`.
  - serialized syscall write path with IRQ-safe spinlock in `kernel/syscall.c` to prevent marker/interleaving regressions in concurrent userspace output.
- Reference docs consulted:
  - `docs/core/C_Library.md`
  - `docs/core/Creating_a_C_Library.md`
  - `docs/core/Cross-Porting_Software.md`
- Verified:
  - `make -j4` passes with `-Wall -Wextra -Werror`.
  - `make demo` passes end-to-end after libc changes.

## 2026-02-10 21:44:55 +0300 - Phase 9, Task 40: Large Userspace Memory Support
- Completed: increased userspace heap headroom so a single process can grow beyond 16MB safely.
- Memory-layout updates:
  - `kernel/process.c`
    - raised `PROCESS_USER_HEAP_LIMIT` from `0x0A000000` (16MB window) to `0x40000000`.
  - `kernel/elf.c`
    - moved ELF user stack mapping from `0x0BFF0000` to `0xBFF00000` to keep stack far from heap growth.
- Runtime validation update:
  - `user/libctest.c`
    - added a direct `sbrk` probe requesting `20MiB`, touching one byte per page, then shrinking back.
- Reference docs consulted:
  - `docs/core/Paging.md`
  - `docs/core/Memory_Allocation.md`
  - `docs/core/Program_Memory_Allocation_Types.md`
  - `docs/core/Loading_a_Process.md`
- Verified:
  - `make -j4` passes with `-Wall -Wextra -Werror`.
  - `make demo` passes.
  - demo serial log includes new marker: `[LIBC] sbrk 20MiB ok`.

## 2026-02-10 22:05:11 +0300 - Phase 9, Task 41: Port doomgeneric
- Completed: vendored `doomgeneric` source and added a ClaudeOS backend entrypoint.
  - Added `user/doomgeneric/*` (upstream doomgeneric sources) and `user/doomgeneric/doomgeneric_claudeos.c`.
  - Added `user/doomgeneric/LICENSE.doomgeneric`.
- Completed: patched portability gaps for ClaudeOS userspace libc/syscall environment.
  - Updated Doom sources (`i_system.c`, `m_misc.c`, `m_config.c`) to avoid unsupported host paths and `sscanf` integer parsing assumptions.
  - Expanded userspace libc surface with required headers/APIs (`ctype`, `strings`, `math`, `errno`, `assert`, `fcntl`, `sys/types`, `sys/stat`, plus `stdlib`/`stdio`/`string` additions).
  - Added libc source units: `stdlib.c`, `ctype.c`, `strings.c`, `math.c`, `errno.c`.
- Build integration:
  - `Makefile` now has a dedicated `doom` target that builds `build/doomgeneric.elf`.
  - Added Doom compile/link object lists and `DOOM_CFLAGS`.
  - Linked Doom ELF with toolchain `libgcc` to satisfy compiler runtime helpers (`__divdi3`).
- Issue encountered and resolved during validation:
  - Kernel growth exceeded existing boot-time kernel sector cap (`KERNEL_MAX_SECTORS=240`), causing `make` failure.
  - Increased cap to `256` and synchronized defaults in `boot/mbr.asm` + `boot/stage2.asm`.
- Reference docs consulted:
  - `docs/core/C_Library.md`
  - `docs/core/Creating_a_C_Library.md`
  - `docs/core/Cross-Porting_Software.md`
  - `docs/core/Portability.md`
- Verified:
  - `make doom -j4` passes and emits `build/doomgeneric.elf` (390360 bytes).
  - `make -j4` passes with updated kernel sector cap.

## 2026-02-10 22:22:23 +0300 - Phase 9, Task 42: Polish (sound stub, FPS timing, input mapping, demo)
- Completed: real timing and input wiring for Doom userspace backend.
  - Added PIT-backed userspace timing syscall and keyboard-event polling syscall:
    - kernel: `kernel/syscall.h`, `kernel/syscall.c`, `kernel/pit.h`, `kernel/keyboard.h`, `kernel/keyboard.c`
    - userspace libc: `user/libc/include/unistd.h`, `user/libc/syscall.c`
  - Keyboard driver now keeps a raw non-blocking event queue (scancode + press/release + extended flag) in addition to ASCII queue.
  - Doom backend (`user/doomgeneric/doomgeneric_claudeos.c`) now:
    - uses real `ticks_ms()` for `DG_GetTicksMs`
    - uses polling sleep against kernel tick source for `DG_SleepMs`
    - maps PS/2 set1 events to Doom keys in `DG_GetKey`
    - applies 35 FPS pacing in main loop
    - prints periodic FPS markers
    - auto-detects IWAD path candidates and emits deterministic guidance if missing.
- Completed: sound-path polish for no-audio target.
  - `user/doomgeneric/i_sound.c` now logs a clear one-time silent-mode marker when no sound/music backend is active on ClaudeOS.
- Completed: Doom launch and demo integration.
  - Added console command `doom`:
    - `kernel/console.c`, `kernel/elf.h`, `kernel/elf.c`
    - spawns `/fat/DOOMGEN.ELF` via VFS/FAT32.
  - FAT32 image tool now optionally embeds built Doom ELF as `DOOMGEN.ELF`:
    - `tools/mkfat32_image.py`
    - `Makefile` updated so `build/fat32.img` depends on `build/doomgeneric.elf`.
  - Added scripted Task 42 validation:
    - `tools/run_task42_demo.sh`
    - `Makefile` target: `doomdemo`.
- Issue encountered and resolved:
  - Attempting to embed Doom ELF in initrd made `kernel.bin` exceed bootloader image cap.
  - Resolved by placing Doom ELF in FAT32 image instead of embedded initrd, keeping kernel size within current bootloader constraints.
  - Found/fixed a userspace startup fault: `crt0` did not pass `argc/argv` to `main()`, causing immediate page fault for GCC-generated Doom `main`.
    - fixed in `user/libc/crt0.asm` by building a valid empty argv frame.
- Reference docs consulted:
  - `docs/core/System_Calls.md`
  - `docs/core/Programmable_Interval_Timer.md`
  - `docs/core/PS_2_Keyboard.md`
  - `docs/core/Sound.md`
- Verified:
  - `make -j4` passes.
  - `make doom -j4` passes.
  - `make demo` (Task 34 regression) passes.
  - `make doomdemo` passes and validates Doom markers in headless QEMU serial log.
